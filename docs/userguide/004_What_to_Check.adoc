[reftext="What to Check"]
== チェックの対象（What to Check）

The following section illustrates some typical checks you could do with ArchUnit.

このセクションでは、ArchUnit の典型的なチェック内容を説明します。

[reftext="Package Dependency Checks"]
=== パッケージの依存性チェック（Package Dependency Checks）

[plantuml, "package-deps-no-access"]
----
skinparam componentStyle uml2
skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

[source] --[#green]right-->  [target]:allowed
[source] --[#crimson]left--> [foo]
note top on link #crimson: forbidden
----

[source,java]
----
noClasses().that().resideInAPackage("..source..")
    .should().dependOnClassesThat().resideInAPackage("..foo..")
----

[plantuml, "package-deps-only-access"]
----
skinparam componentStyle uml2
skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

[source.one] --[#green]right-->  [source.two]:allowed
[source.one] --[#green]--> [foo]:allowed
[source.two] --[#crimson]down--> [foo]
note top on link #crimson: forbidden
[source.any] --[#crimson]down--> [foo]
note top on link #crimson: forbidden
----

[source,java]
----
classes().that().resideInAPackage("..foo..")
    .should().onlyHaveDependentClassesThat().resideInAnyPackage("..source.one..", "..foo..")
----

[reftext="Class Dependency Checks"]
=== クラスの依存性チェック（Class Dependency Checks）

[plantuml, "class-naming-deps"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

class Other
class FooBar

Other -> FooBar
note top on link #crimson: forbidden

Bar --> FooBar #green
note left on link #green: allowed
----

[source,java]
----
classes().that().haveNameMatching(".*Bar")
    .should().onlyHaveDependentClassesThat().haveSimpleName("Bar")
----

[reftext="Class and Package Containment Checks"]
=== クラスおよびパッケージの閉じ込め状況チェック（Class and Package Containment Checks）

[plantuml, "class-package-contain"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

package com.foo {
    class FooService
}

package com.wrong {
    class FooController
}

note "resides in wrong package" as WrongPackage #crimson
FooController .. WrongPackage
----

[source,java]
----
classes().that().haveSimpleNameStartingWith("Foo")
    .should().resideInAPackage("com.foo")
----

[reftext="Inheritance Checks"]
=== 継承関係のチェック（Inheritance Checks）

[plantuml, "inheritance-naming-check"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

class Connection <<interface>>
class HtmlConnection <<concrete>>
class FtpConnection <<concrete>>
class SshThing <<concrete>>

HtmlConnection --|> Connection #green
FtpConnection --|> Connection #green
SshThing --|> Connection #crimson

note right on link #crimson: Has wrong name
----

[source,java]
----
classes().that().implement(Connection.class)
    .should().haveSimpleNameEndingWith("Connection")
----

[plantuml, "inheritance-access-check"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

package com.myapp.persistence {
    class ValidPersistenceUser
}

package com.myapp.somewhereelse {
    class IllegalPersistenceUser
}

class EntityManager

ValidPersistenceUser --> EntityManager #green
IllegalPersistenceUser --> EntityManager #crimson

note right on link #crimson: Accessor resides in wrong package
----

[source,java]
----
classes().that().areAssignableTo(EntityManager.class)
    .should().onlyHaveDependentClassesThat().resideInAnyPackage("..persistence..")
----

[reftext="Annotation Checks"]
=== アノテーションのチェック（Annotation Checks）

[plantuml, "inheritance-annotation-check"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

class ValidPersistenceUser <<@Transactional>>
class IllegalPersistenceUser <<not transactional>>

class EntityManager

ValidPersistenceUser --> EntityManager #green
IllegalPersistenceUser --> EntityManager #crimson

note right on link #crimson: Accessor is not annotated with @Transactional
----

[source,java]
----
classes().that().areAssignableTo(EntityManager.class)
    .should().onlyHaveDependentClassesThat().areAnnotatedWith(Transactional.class)
----

[reftext="Layer Checks"]
=== レイヤーのチェック（Layer Checks）

[plantuml, "layer-check"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

package com.myapp.controller {
    class SomeControllerOne
    class SomeControllerTwo
}
package com.myapp.service {
    class SomeServiceOne
    class SomeServiceTwo
}
package com.myapp.persistence {
    class SomePersistenceManager
}

SomeControllerOne --> SomeServiceOne #green
SomeServiceTwo -down-> SomePersistenceManager #green

SomeControllerOne -down-> SomePersistenceManager #crimson
note right on link #crimson: Access bypasses layers

SomeServiceTwo -up--> SomeControllerTwo #crimson
note right on link #crimson: Access goes against layers

SomePersistenceManager -up--> SomeServiceOne #crimson
note right on link #crimson: Access goes against layers
----

[source,java]
----
layeredArchitecture()
    .layer("Controller").definedBy("..controller..")
    .layer("Service").definedBy("..service..")
    .layer("Persistence").definedBy("..persistence..")

    .whereLayer("Controller").mayNotBeAccessedByAnyLayer()
    .whereLayer("Service").mayOnlyBeAccessedByLayers("Controller")
    .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Service")
----

[reftext="Cycle Checks"]
=== 循環のチェック（Cycle Checks）

[plantuml, "cycle-check"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

package com.myapp.moduleone {
    class ClassOneInModuleOne
    class ClassTwoInModuleOne
}
package com.myapp.moduletwo {
    class ClassOneInModuleTwo
    class ClassTwoInModuleTwo
}
package com.myapp.modulethree {
    class ClassOneInModuleThree
    class ClassTwoInModuleThree
}

ClassOneInModuleOne --> ClassTwoInModuleTwo #crimson
ClassOneInModuleTwo --> ClassOneInModuleThree #crimson
ClassTwoInModuleThree --> ClassOneInModuleOne #crimson
note right on link #crimson: Combination of accesses forms cycle
----

[source,java]
----
slices().matching("com.myapp.(*)..").should().beFreeOfCycles()
----
