[reftext="Getting Started"]
== ArchUnit 入門（Getting Started）

ArchUnit tests are written the same way as any Java unit test and can be written with any
Java unit testing framework. To really understand the ideas behind ArchUnit, one should consult
<<Ideas and Concepts>>. The following will outline a "technical" getting started.

ArchUnit のテストはユニットテストと同じやり方で、そしてあらゆるユニットテストフレームワークを使用して記述できます。
ArchUnit の背景となる考え方を正確に理解したければ、<<Ideas and Concepts>>を読んでみてください。
以降の説明は「技術的な」入門です。

[reftext="Importing Classes"]
=== クラスのインポート（Importing Classes）

At its core ArchUnit provides infrastructure to import Java bytecode into Java code structures.
This can be done using the `ClassFileImporter`

ArchUnitの基本部品は、Javaバイトコードをソースコード構造へインポートする `ClassFileImporter` です。

[source,java,options="nowrap"]
----
JavaClasses classes = new ClassFileImporter().importPackages("com.mycompany.myapp");
----

The `ClassFileImporter` offers many ways to import classes. Some ways depend on
the current project's classpath, like `importPackages(..)`. However there are other ways
that do not, for example:

`ClassFileImpoter` はクラスをインポートするためのさまざまな方法を提供します。
`importPackages(..)` のようにプロジェクトのクラスパスへ依存する方法もありますが、次のようにそうでない方法もあります。

[source,java,options="nowrap"]
----
JavaClasses classes = new ClassFileImporter().importPath("/some/path");
----

The returned object of type `JavaClasses` represents a collection of elements of type
`JavaClass`, where `JavaClass` in turn represents a single imported class file. You can
in fact access most properties of the imported class via the public API:

返り値の `JavaClasses` 型のオブジェクトは、`JavaClass` 型のオブジェクトの集合です。
`JavaClass` はインポートしたいずれかのクラスファイルに対応しています。
public APIにより、インポートしたクラスのほとんどのプロパティを参照できます。

[source,java,options="nowrap"]
----
JavaClass clazz = classes.get(Object.class);
System.out.print(clazz.getSimpleName()); // returns 'Object'
----

[reftext="Asserting (Architectural) Constraints"]
=== （アーキテクチャにおける）制約のアサーション（Asserting (Architectural) Constraints）

To express architectural rules, like 'Services should only be accessed by Controllers',
ArchUnit offers an abstract DSL-like fluent API, which can in turn be evaluated against
imported classes. To specify a rule, use the class `ArchRuleDefinition` as entry point:

例えば「サービスにアクセスできるのはコントローラーだけでなければならない」というアーキテクチャルールを ArchUnit で表現するには、フルーエントAPIを抽象的なDSLとして、インポートしたクラスを評価できます。
実際にルールを定義するときは、`ArchRuleDefinition` クラスを起点にします。

[source,java,options="nowrap"]
----
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

// ...

ArchRule myRule = classes()
    .that().resideInAPackage("..service..")
    .should().onlyBeAccessed().byAnyPackage("..controller..", "..service..");
----

The two dots represent any number of packages (compare AspectJ Pointcuts). The returned
object of type `ArchRule` can now be evaluated against a set of imported classes:

パッケージ名を指定する文字列に含まれる連続する2つのドットは、任意の数のパッケージ階層を表しています（AspectJ のポイントカットを記述する場合と同様です）。
返り値の `ArchRule` 型のオブジェクトを使うと、インポートしたクラスの集合を評価できます。

[source,java,options="nowrap"]
----
myRule.check(importedClasses);
----

Thus the complete example could look like

全てを組み合わせた完全な具体例は次のとおりです。

[source,java,options="nowrap"]
----
@Test
public void Services_should_only_be_accessed_by_Controllers() {
    JavaClasses importedClasses = new ClassFileImporter().importPackages("com.mycompany.myapp");

    ArchRule myRule = classes()
        .that().resideInAPackage("..service..")
        .should().onlyBeAccessed().byAnyPackage("..controller..", "..service..");

    myRule.check(importedClasses);
}
----

[reftext="Using JUnit 4 or JUnit 5"]
=== JUnit 4 と JUnit 5 のどちらかを使いましょう（Using JUnit 4 or JUnit 5）

While ArchUnit can be used with any unit testing framework, it provides extended support
for writing tests with JUnit 4 and JUnit 5. The main advantage is automatic caching of imported
classes between tests (of the same imported classes), as well as reduction of boilerplate code.

ArchUnit はどのようなユニットテストフレームワークでも使用できますが、JUnit4 あるいは JUnit 5 を使ってテストを書くための拡張機能が備わっています。
主な利点はインポートしたクラスのキャッシュをテストケース間で再利用できることです。
そうすると、ボイラープレートコードの記述を減らすことができます。

To use the JUnit support, declare ArchUnit's `ArchUnitRunner` (only JUnit 4), declare the classes
to import via `@AnalyzeClasses` and add the respective rules as fields:

JUnit 用の拡張機能を使うには、`ArchUnitRunner` を宣言し（JUnit 4 の場合のみ）、インポートするクラスを `@AnalyzeClasses` で指定します。
そして、ルールをテストクラスのフィールドとして定義します。

[source,java,options="nowrap"]
----
@RunWith(ArchUnitRunner.class) // Remove this line for JUnit 5!!
@AnalyzeClasses(packages = "com.mycompany.myapp")
public class MyArchitectureTest {

    @ArchTest
    public static final ArchRule myRule = classes()
        .that().resideInAPackage("..service..")
        .should().onlyBeAccessed().byAnyPackage("..controller..", "..service..");

}
----

The JUnit test support will automatically import (or reuse) the specified classes and
evaluate any rule annotated with `@ArchTest` against those classes.

JUnit 用の拡張機能は、指定したクラスを自動的にインポートし、再利用するようになります。
また、`@ArchTest` で修飾されたあらゆるルールを評価するようになります。

For further information on how to use the JUnit support refer to <<JUnit Support>>.

より詳しい使い方は <<JUnit Support>> を参照してください。

[reftext="Using JUnit support with Kotlin"]
=== Kotlin で JUnit を使う（Using JUnit support with Kotlin）

Using the JUnit support with Kotlin is quite similar to Java:

JUnit 用の拡張機能を Kotlin から使う方法は Java の場合とほとんど変わりません。

[source,kotlin,options="nowrap"]
----
@RunWith(ArchUnitRunner::class) // Remove this line for JUnit 5!!
@AnalyzeClasses(packagesOf = [MyArchitectureTest::class])
class MyArchitectureTest {
    @ArchTest
    val rule_as_field = ArchRuleDefinition.noClasses().should()...

    @ArchTest
    fun rule_as_method(importedClasses: JavaClasses) {
        val rule = ArchRuleDefinition.noClasses().should()...
        rule.check(importedClasses)
    }
}
----
