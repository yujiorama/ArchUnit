[reftext="The Core API"]
== コア API（The Core API）

The Core API is itself divided into the domain objects and the actual import.

コア API はドメインオブジェクトとインポートに関連する部分へ分かれています。

[reftext="Import"]
=== インポート（Import）

As mentioned in <<Ideas and Concepts>> the backbone of the infrastructure is the `ClassFileImporter`,
which provides various ways to import Java classes. One way is to import packages from
the classpath, or the complete classpath via

<<Ideas and Concepts>>でも説明したように、基本部品は `ClassFileImporter` クラスです。
このクラスは Java クラスファイルをインポートするためのさまざまな方法を提供します。
クラスパスに存在するパッケージを指定する方法や、完全なクラスパスを指定する方法があります。

[source,java,options="nowrap"]
----
JavaClasses classes = new ClassFileImporter().importClasspath();
----

However, the import process is completely independent of the classpath, so it would be well possible
to import any path from the file system:

ただし、インポート処理自体はクラスパスと完全に独立しているため、ファイルシステム上の任意のパスを指定できるようになっています。

[source,java,options="nowrap"]
----
JavaClasses classes = new ClassFileImporter().importPath("/some/path/to/classes");
----

The `ClassFileImporter` offers several other methods to import classes, for example locations can be
specified as URLs or as JAR files.

`ClassFileImporter` クラスは、クラスをインポートするためのさまざまな方法を提供しています。
例えば、URL や JAR ファイルでインポートする位置を指定できるようになっています。

Furthermore specific locations can be filtered out, if they are contained in the source of classes,
but should not be imported. A typical use case would be to ignore test classes, when the classpath
is imported. This can be achieved by specifying `ImportOptions`:

指定した位置の中から一部を除外できるようにもなっているため、インポートするべきではないクラスを無視できます。
テストクラスを除外するのはよくある使い方の1つです。
具体的には `ImportOptions` を指定します。

[source,java,options="nowrap"]
----
ImportOption ignoreTests = new ImportOption() {
    @Override
    public boolean includes(Location location) {
        return !location.contains("/test/"); // ignore any URI to sources that contains '/test/'
    }
};

JavaClasses classes = new ClassFileImporter().withImportOption(ignoreTests).importClasspath();
----

A `Location` is principally an URI, i.e. ArchUnit considers sources as File or JAR URIs

基本的に `Location` は URI として扱います。
ArchUnit は指定された `Location` を `File` あるいは `JAR` を指す `URI` として扱うということです。

* `file:///home/dev/my/project/target/classes/some/Thing.class`
* `jar:file:///home/dev/.m2/repository/some/things.jar!/some/Thing.class`

For the two common cases to skip importing JAR files and to skip importing test files
(for typical setups, like a Maven or Gradle build),
there already exist predefined `ImportOptions`:

Maven や Gradle のプロジェクトで一般的な2種類のケース、つまり、JARファイルやテストクラスをインポート対象から除外するケースは `ImportOptions` に定義済みです。

[source,java,options="nowrap"]
----
new ClassFileImporter()
    .withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_JARS)
    .withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_TESTS)
    .importClasspath();
----

[reftext="Dealing with Missing Classes"]
==== 存在しないクラスの扱い（Dealing with Missing Classes）

While importing the requested classes (e.g. `target/classes` or `target/test-classes`)
it can happen that a class within the scope of the import has a reference to a class outside of the
scope of the import. This will naturally happen, if the classes of the JDK are not imported,
since then for example any dependency on `Object.class` will be unresolved within the import.

`target/classes` や `target/test-classes` などを指定してインポートしたクラスが、指定した場所に存在しないクラスを参照している場合があります。
自然に発生する状況ですが、例えば JDK に含まれるクラスをインポートしていなければ、 `Object.class` に対する全ての依存関係は未解決になってしまいます。

At this point ArchUnit needs to decide how to treat these classes that are missing from the
import. By default, ArchUnit searches within the classpath for missing classes and if found
imports them. This obviously has the advantage that information about those classes
(which interfaces they implement, how they are annotated) is present during rule evaluation.

ArchUnit はインポートしたクラスに存在しないクラスを発見したときにどうするか決めておかなければなりません。
初期設定では存在しないクラスを発見したら、クラスパスを探索するようになっています。
ルールを評価するとき、実装しているインターフェイスやアノテーションなどの情報を利用できるのは大きな利点になります。

On the downside this additional lookup from the classpath will cost some performance and in some
cases might not make sense (e.g. if information about classes not present in the original import
is known to be unnecessary for evaluating rules).
Thus ArchUnit can be configured to create stubs instead, i.e. a `JavaClass` that has all the known
information, like the fully qualified name or the method called. However, this stub might
naturally lack some information, like superclasses, annotations or other details that cannot
be determined without importing the bytecode of this class. This behavior will also happen,
if ArchUnit fails to determine the location of a missing class from the classpath.

クラスパスを探索することの欠点は、時間が長くなってしまうことと無意味な結果しか得られない場合があることです。
例えば、インポートできたクラスに存在しないクラスの情報が、ルールの評価に不要なことが分かっている場合が挙げられます。
そういう場合について、ArchUnit ではスタブを生成できるようになっています。
具体的には `JavaClass` クラスは完全修飾名やメソッド呼び出しなど必要な全ての情報を持っています。
しかし、本質的にスタブには不足している情報があります。
基底クラスやアノテーション等、クラスファイル（バイトコード）をインポートしなければ決定できない情報のことです。
これは、ArchUnit がクラスパスを探索してもクラスを発見できなかった場合の振る舞いでもあります。

To find out, how to configure the default behavior, refer to <<Configuring the Resolution Behavior>>.

振る舞いを変更する方法について知りたければ <<Configuring the Resolution Behavior>> を参照してください。

[reftext="Domain"]
=== ドメイン（Domain）

The domain objects represent Java code, thus the naming should be pretty straight forward. Most
commonly, the `ClassFileImporter` imports instances of type `JavaClass`. A rough overview looks
like this:

ドメインオブジェクトは Java のソースコードを直接的な名前で表現します。
ほとんどの場合 `ClassFileImporter` は `JavaClass` 型のインスタンスをインポートします。
基本的な構造は次のとおりです。

[plantuml, "domain-overview"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

class JavaPackage
class JavaClass
class JavaMember
class JavaField
class JavaCodeUnit
class ThrowsClause
class JavaConstructor
class JavaMethod
class JavaStaticInitializer

class JavaFieldAccess
class JavaConstructorCall
class JavaMethodCall

JavaPackage *--* "1..*" JavaClass : has
JavaClass *-- "0..*" JavaMember : has
JavaMember <|-- JavaField : extends
JavaMember <|-- JavaCodeUnit : extends
JavaCodeUnit <|-- JavaConstructor : extends
JavaCodeUnit <|-- JavaMethod : extends
JavaCodeUnit <|-- JavaStaticInitializer : extends
JavaConstructor *-- "1" ThrowsClause : has
JavaMethod *-- "1" ThrowsClause : has

JavaCodeUnit *-- "0..*" JavaFieldAccess : has
JavaCodeUnit *-- "0..*" JavaMethodCall : has
JavaCodeUnit *-- "0..*" JavaConstructorCall : has
----

Most objects resemble the Java Reflection API, including inheritance relations. Thus a `JavaClass`
has `JavaMembers`, which can in turn be either `JavaField`, `JavaMethod`,
`JavaConstructor` (or `JavaStaticInitializer`). While not present within the reflection API,
it makes sense to introduce an expression for anything that can access other code, which ArchUnit
calls 'code unit', and is in fact either a method, a constructor (including the class initializer)
or a static initializer of a class (e.g. a `static { ... }` block, a static field assignment,
etc.).

ほとんどのオブジェクトは、継承関係も含めて Java のリフレクション API とよく似た形式になっています。
`JavaClass` は `JavaMembers` を持っているし、`JavaMembers` は `JavaField` や `JavaMethod` や `JavaConstructor` （あるいは `JavaStaticInitializer`）のいずれかになります。
リフレクション API には存在しませんが、他のコードへアクセスする表現はあると便利です。
ArchUnit では「コードユニット（code unit）」と呼んでいる要素で、メソッドやコンストラクタ、クラスイニシャライザ、静的イニシャライザ（`static { ... }` ブロックやクラスフィールドの初期化など）に対応します。

Furthermore one of the most interesting features of ArchUnit that exceeds the Java Reflection API,
is the concept of accesses to another class. On the lowest level accesses can only take place
from a code unit (as mentioned, any block of executable code) to either a field (`JavaFieldAccess`),
a method (`JavaMethodCall`) or constructor (`JavaConstructorCall`).

ArchUnit が Java リフレクション API を拡張している中で最も面白い機能は他のクラスへのアクセス、という考え方です。
最も抽象度が低いのは、コードユニットからフィールド（`JavaFieldAccess`）やメソッド（`JavaMethodCall`）やコンストラクタ（`JavaConstructorCall`）に対するアクセスです。

ArchUnit imports the whole graph of classes and their relationship to each other. While checking
the accesses *from* a class is pretty isolated (the bytecode offers all this information),
checking accesses *to* a class requires the whole graph to be built first. To distinguish which
sort of access is referred to, methods will always clearly state *fromSelf* and *toSelf*.
For example, every `JavaField` allows to call `JavaField#getAccessesToSelf()` to retrieve all
code units within the graph that access this specific field. The resolution process through
inheritance is not completely straight forward. Consider for example

ArchUnit は全てのクラスの呼び出しグラフとクラス間の関係性を別々にインポートします。
*アクセス元* のクラスに対するチェックは完全に独立しています（全ての情報はバイトコードから取得します）が、 *アクセス先* のクラスをチェックするには最初に構築したグラフ情報が必要です。
どちらからアクセスしているのか区別するため、それぞれのメソッドは *fromSelf* と *toSelf* の状態を持つようになっています。
例えば、全ての `JavaField` は `JavaField#getAccessesToSelf()` でそのフィールドへアクセスするグラフ中の全てのコードユニットを取得できるようになっています。
継承関係のあるクラスにおける呼び出し元の解決処理は極めて複雑です。
次のような例を考えてみてください。

[plantuml, "resolution-example"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

class ClassAccessing {
  void accessField()
}

class ClassBeingAccessed
class SuperclassBeingAccessed {
  Object accessedField
}

SuperclassBeingAccessed <|-- ClassBeingAccessed
ClassAccessing o-- ClassBeingAccessed

----

The bytecode will record a field access from `ClassAccessing.accessField()` to
`ClassBeingAccessed.accessedField`. However, there is no such field, since the field is
actually declared in the superclass. This is the reason why a `JavaFieldAccess`
has no `JavaField` as its target, but a `FieldAccessTarget`. In other words, ArchUnit models
the situation, as it is found within the bytecode, and an access target is not an actual
member within another class. If a member is queried for `accessesToSelf()` though, ArchUnit
will resolve the necessary targets and determine, which member is represented by which target.
The situation looks roughly like

バイトコードには `ClassAccessing.accessField()` から `ClassBeingAccessed.accessedField` へアクセスしていることが記録されているでしょう。
しかし、実際にはそんなフィールドは存在しません。
基底クラスで定義されているからです。
`JavaFieldAccess` の対象に1つも `JavaField` が含まれておらず、`FieldAccessTarget` が存在するのはそのせいです。
別の言い方をすると、ArchUnit はバイトコードから得られた状況をモデル化していると言えます。
アクセスしている対象自体はそのクラスのメンバーではないのです。
メンバーを `accessToSelf()` で問い合わせれば、ArchUnit は必要な対象を発見、特定できます。
対象自体がメンバーを表現しているからです。
例えば次のような状況です。

[plantuml, "resolution-overview"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

class JavaFieldAccess
class FieldAccessTarget
class JavaField
class JavaMethodCall
class MethodCallTarget
class JavaMethod
class JavaConstructorCall
class ConstructorCallTarget
class JavaConstructor

JavaFieldAccess "1" *-- "1" FieldAccessTarget : has
FieldAccessTarget "1" -- "0..1" JavaField : resolves to

JavaMethodCall "1" *-- "1" MethodCallTarget : has
MethodCallTarget "1" -- "0..*" JavaMethod : resolves to

JavaConstructorCall "1" *-- "1" ConstructorCallTarget : has
ConstructorCallTarget "1" -- "0..1" JavaConstructor : resolves to
----

Two things might seem strange at the first look.

一見すると奇妙なところが2点見つけられます。

First, why can a target resolve to zero matching members? The reason is that the set of classes
that was imported does not need to have all classes involved within this resolution process.
Consider the above example, if `SuperclassBeingAccessed` would not be imported, ArchUnit would
have no way of knowing where the actual targeted field resides. Thus in this case the
resolution would return zero elements.

1点目は、対象を解決した結果となるメンバー数が0になる場合があることです。
原因は、インポートしたクラスに、この解決処理に関係する全てのクラスが必要だとは限らないからです。
前の例では `SuperclassBeingAccessed` がインポートされていますが、ArchUnit には実際にどのようなフィールドが存在するのか知る手段がありません。
だから、解決結果の要素数が0になる場合があるのです。

Second, why can there be more than one resolved methods for method calls?
The reason for this is that a call target might indeed match several methods in those
cases, for example:

2点目は、メソッド呼び出しを解決した結果が1以上になる場合があることです。
原因は、実際に対象のメソッドが複数回呼び出されている場合があることです。
例えば次のような場合があります。

[plantuml, "diamond-example"]
----
skinparam componentStyle uml2

skinparam component {
  BorderColor #grey
  BackgroundColor #white
}

skinparam class {
  BorderColor #grey
  BackgroundColor #white
}

class A <<interface>> {
  void targetMethod()
}
class B <<interface>> {
  void targetMethod()
}
class C <<abstract>> {
}
class D {
  void callTargetMethod()
}

A <|-- C : implements
B <|-- C : implements
D -right- C : calls targetMethod()
----

While this situation will always be resolved in a specified way for a real program,
ArchUnit cannot do the same. Instead, the resolution will report all candidates that match a
specific access target, so in the above example, the call target `C.targetMethod()` would in fact
resolve to two `JavaMethods`, namely `A.targetMethod()` and `B.targetMethod()`. Likewise a check
of either `A.targetMethod.getCallsToSelf()` or `B.targetMethod.getCallsToSelf()` would return
the same call from `D.callTargetMethod()` to `C.targetMethod()`.

実際のプログラムなら常に特別な方法で解決するような状況ですが、ArchUnit には解決できません。
代わりに、具体的なアクセス対象にマッチする全ての候補を報告します。
前の例では呼び出し対象の `C.targetMethod()` について、`A.targetMethod()` および `B.targetMethod()` という2つの `JavaMethods` を報告します。
同様に、`A.targetMethod.getCallsToSelf()` や `B.targetMethod.getCallsToSelf()` のどちらも、`D.callTargetMethod()` から `C.targetMethod()` と同じ呼び出し対象を返すことになります。

[reftext="Domain Objects, Reflection and the Classpath"]
==== ドメインオブジェクト、リフレクション、クラスパス（Domain Objects, Reflection and the Classpath）

ArchUnit tries to offer a lot of information from the bytecode. For example, a `JavaClass`
provides details like if it is an enum or an interface, modifiers like `public` or `abstract`,
but also the source, where this class was imported from (namely the URI mentioned in the first
section). However, if information is missing, and the classpath is correct, ArchUnit offers
some convenience to rely on the reflection API for extended details. For this reason, most
`Java*` objects offer a method `reflect()`, which will in fact try to resolve the respective
object from the Reflection API. For example:

ArchUnit はバイトコードから取得した多くの情報をできるだけ提供できるように試みます。
例えば、`JavaClass` ならそれが enum なのか interface なのか教えてくれるし、`public` 修飾子や `abstract` 修飾子についても教えてくれます。
また、どこからインポートしたクラスなのかも教えてくれます（前のセクションで説明した URI のことです）。
そして、正しいクラスパスが与えられているのに情報が欠落している場合、ArchUnit はリフレクション API を駆使して更なる詳細の提供を試みます。
ほとんどの `Java*` オブジェクトには `reflect()` メソッドが存在するのはそのためです。
このメソッドはリフレクション API でオブジェクトの情報を解決しようとします。

[source,java,options="nowrap"]
----
JavaClasses classes = new ClassFileImporter().importClasspath(new ImportOptions());

// ArchUnit's java.lang.String
JavaClass javaClass = classes.get(String.class);
// Reflection API's java.lang.String
Class<?> stringClass = javaClass.reflect();

// ArchUnit's public int java.lang.String.length()
JavaMethod javaMethod = javaClass.getMethod("length");
// Reflection API's public int java.lang.String.length()
Method lengthMethod = javaMethod.reflect();
----

However, this will throw an `Exception`, if the respective classes are missing on the classpath
(e.g. because they were just imported from some file path).

ただし、対応するクラスがクラスパス上に存在しない場合（ファイルパスからインポートした場合等）、このメソッドは `Exception` を送出します。

This restriction also applies to handling annotations in a more convenient way.
Consider the following annotation:

この制限は、アノテーションをより便利に扱う方法を提供します。
例えば、次のようなアノテーションがあるとします。

[source,java,options="nowrap"]
----
@interface CustomAnnotation {
    String value();
}
----

If you need to access this annotation without it being on the classpath, you must rely on

このアノテーションがクラスパス上に存在しなくてもアクセスしなければならないときは次のようにするしかありません。

[source,java,options="nowrap"]
----
JavaAnnotation<?> annotation = javaClass.getAnnotationOfType("some.pkg.CustomAnnotation");
// result is untyped, since it might not be on the classpath (e.g. enums)
Object value = annotation.get("value");
----

So there is neither type safety nor automatic refactoring support. If this annotation is on the classpath, however,
this can be written way more naturally:

この場合型安全性は保証されませんし、自動的なリファクタリング支援も得られません。
アノテーションがクラスパス上に存在するなら、次のようにより自然に記述できます。

[source,java,options="nowrap"]
----
CustomAnnotation annotation = javaClass.getAnnotationOfType(CustomAnnotation.class);
String value = annotation.value();
----

ArchUnit's own rule APIs (compare <<The Lang API>>) never rely on the
classpath though. Thus the evaluation of default rules and syntax combinations, described in the
next section, does not depend on whether the classes were imported from the classpath or
some JAR / folder.

ArchUnit 自身のルール API （<<The Lang API>> を参照）はクラスパスに依存していません。
つまり、次のセクションで説明する、基本ルールやルール構文の組み合わせを評価するときは、クラスパスやJARあるいはフォルダのどこからクラスをインポートしても関係ないのです。
